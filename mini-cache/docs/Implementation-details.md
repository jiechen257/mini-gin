## 交互流程

```text
                            是
接收 key --> 检查是否被缓存 -----> 返回缓存值 ⑴
                |  否                         是
                |-----> 是否应当从远程节点获取 -----> 与远程节点交互 --> 返回缓存值 ⑵
                            |  否
                            |-----> 调用`回调函数`，获取值并添加到缓存 --> 返回缓存值 ⑶
```

## 目录结构

```txt
geecache/
    |--lru/
        |--lru.go  // lru 缓存淘汰策略
    |--byteview.go // 缓存值的抽象与封装
    |--cache.go    // 并发控制
    |--miniCache.go // 负责与外部交互，控制缓存存储和获取的主流程
		|--http.go     // 提供被其他节点访问的能力(基于http)
```

## Group 结构

一个 Group 可以认为是一个缓存的命名空间，每个 Group 拥有一个唯一的名称 name。比如可以创建三个 Group，缓存学生的成绩命名为 scores，缓存学生信息的命名为 info，缓存学生课程的命名为 courses

第二个属性是 getter Getter，即缓存未命中时获取源数据的回调(callback)

第三个属性是 mainCache cache，即一开始实现的并发缓存

## 一致性哈希

针对同一个缓存的 key ,使得每次访问时都是由同一个节点进行数据返回

> 缓存雪崩：缓存在同一时刻全部失效，造成瞬时 DB 请求量大、压力骤增，引起雪崩。常因为缓存服务器宕机，或缓存设置了相同的过期时间引起

一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环

计算节点/机器(通常使用节点的名称、编号和 IP 地址)的哈希值，放置在环上
计算 key 的哈希值，放置在环上，顺时针寻找到的第一个节点，就是应选取的节点/机器
![](https://cdn.jsdelivr.net/gh/jiechen257/personal-gallery@main/img/202404231655277.png)
